<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <title>비밀번호 재설정</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" th:href="@{/login/css/resetPassword.css}">

  <!-- CSRF 메타 (스프링 시큐리티) -->
  <meta name="_csrf" th:content="${_csrf.token}">
  <meta name="_csrf_header" th:content="${_csrf.headerName}">
</head>
<body>
<div class="wrap">
  <div class="wrap-inner">
    <div class="card">
      <div class="card-header">
        <h1 class="title">비밀번호 재설정</h1>
      </div>

      <div class="card-body">
        <form id="resetForm" th:action="@{/account/reset}" method="post">
          <!-- CSRF: 존재할 때만 렌더 -->
          <input type="hidden"
                 th:if="${_csrf != null}"
                 th:name="${_csrf.parameterName}"
                 th:value="${_csrf.token}" />

          <div class="group">
            <label class="label">새 비밀번호</label>
            <input id="newPw" class="input" type="password" name="newPassword"
                   placeholder="8자 이상, 2종류 이상 조합" required>
            <div id="newPwMsg" class="help"></div>
          </div>

          <div class="group">
            <label class="label">새 비밀번호 확인</label>
            <input id="confirmPw" class="input" type="password" name="confirmPassword"
                   placeholder="다시 입력" required>
            <div id="confirmPwMsg" class="help"></div>
          </div>

          <div class="actions">
            <button id="submitBtn" type="submit" class="btn btn-primary" disabled>변경</button>
            <a th:href="@{/account/find(tab='pw')}" class="link">비밀번호 찾기 화면으로 돌아가기</a>
          </div>

          <!-- 필요 시 서버 메시지 -->
          <div class="help" th:if="${msg}" th:text="${msg}"></div>
        </form>
      </div>
    </div>
  </div>
</div>

<script>
(function () {
  const MIN_LEN = 8;
  const NEED_CAT = 2;

  const $newPw = document.getElementById("newPw");
  const $confirmPw = document.getElementById("confirmPw");
  const $submitBtn = document.getElementById("submitBtn");
  const $newPwMsg = document.getElementById("newPwMsg");
  const $cfmPwMsg = document.getElementById("confirmPwMsg");
  const form = document.getElementById("resetForm");

  const csrfToken = document.querySelector('meta[name="_csrf"]')?.content;
  const csrfHeader = document.querySelector('meta[name="_csrf_header"]')?.content;

  let sameAsOld = false;     // 서버 비교 결과 (동일 여부)
  let debounceTimer = null;  // 디바운스용

  function categoriesCount(pw) {
    let c = 0;
    if (/[A-Z]/.test(pw)) c++;
    if (/[a-z]/.test(pw)) c++;
    if (/\d/.test(pw)) c++;
    if (/[^A-Za-z0-9]/.test(pw)) c++;
    return c;
  }

  function unmetRequirements(pw) {
    const unmet = [];
    if (pw.length < MIN_LEN) unmet.push(`길이 ${MIN_LEN}자 이상`);
    if (categoriesCount(pw) < NEED_CAT) unmet.push("영대/영소/숫자/특수문자 중 2종 이상");
    if (sameAsOld) unmet.push("기존 비밀번호와 동일하게 설정할 수 없습니다.");
    return unmet;
  }

  function strengthText(pw) {
    const len = pw.length, cat = categoriesCount(pw);
    if (len >= MIN_LEN && cat >= NEED_CAT) {
      if (len >= 12 && cat >= 3) return "강함";
      if (len >= 10 && cat >= 2) return "보통";
    }
    return "약함";
  }

  async function checkSameOnServer(pw) {
    // 비어있으면 검사할 필요 없음
    if (!pw) { sameAsOld = false; return; }

    try {
      const res = await fetch("/account/api/check-same", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
          ...(csrfToken && csrfHeader ? { [csrfHeader]: csrfToken } : {})
        },
        body: "newPassword=" + encodeURIComponent(pw)
      });
      const data = await res.json();
      sameAsOld = !!data.same; // 동일하면 true
    } catch (e) {
      // 네트워크 오류 시에는 동일 체크를 막지 않되, 메시지는 표시 가능
      sameAsOld = false;
    }
  }

  function renderNewPwMessage(pw) {
    const unmet = unmetRequirements(pw);
    if (unmet.length > 0) {
      $newPw.classList.add("is-invalid");
      $newPw.classList.remove("is-valid");
      $newPwMsg.textContent = "❌ 조건 미충족: " + unmet.join(" · ");
      $newPwMsg.style.color = "#d00";
      return false;
    } else {
      $newPw.classList.add("is-valid");
      $newPw.classList.remove("is-invalid");
      $newPwMsg.innerHTML = "✅ 사용 가능 · 강도: <b>" + strengthText(pw) + "</b>";
      $newPwMsg.style.color = "#067";
      return true;
    }
  }

  function validateMatch() {
    const pw = $newPw.value;
    const cfm = $confirmPw.value;
    if (!cfm) {
      $confirmPw.classList.remove("is-valid", "is-invalid");
      $cfmPwMsg.textContent = "";
      return false;
    }
    if (pw === cfm) {
      $confirmPw.classList.add("is-valid");
      $confirmPw.classList.remove("is-invalid");
      $cfmPwMsg.textContent = "✅ 일치합니다.";
      $cfmPwMsg.style.color = "#067";
      return true;
    } else {
      $confirmPw.classList.add("is-invalid");
      $confirmPw.classList.remove("is-valid");
      $cfmPwMsg.textContent = "❌ 새 비밀번호와 확인 비밀번호가 다릅니다.";
      $cfmPwMsg.style.color = "#d00";
      return false;
    }
  }

  function toggleSubmit() {
    const ok = renderNewPwMessage($newPw.value) && validateMatch();
    $submitBtn.disabled = !ok;
  }

  // 입력 시: 디바운스로 서버 동일여부 체크 → 메시지 갱신
  $newPw.addEventListener("input", () => {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(async () => {
      await checkSameOnServer($newPw.value);
      renderNewPwMessage($newPw.value);
      validateMatch();
      toggleSubmit();
    }, 250);
  });

  $newPw.addEventListener("blur", async () => {
    await checkSameOnServer($newPw.value);
    renderNewPwMessage($newPw.value);
    validateMatch();
    toggleSubmit();
  });

  $confirmPw.addEventListener("input", () => {
    validateMatch();
    toggleSubmit();
  });

  form.addEventListener("submit", async function (e) {
    await checkSameOnServer($newPw.value);
    const ok = renderNewPwMessage($newPw.value) && validateMatch();
    if (!ok) {
      e.preventDefault();
      alert("비밀번호 조건을 확인해 주세요.");
    }
  });
})();
</script>
</body>
</html>
